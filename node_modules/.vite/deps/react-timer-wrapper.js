import {
  es_default
} from "./chunk-PTPDQCAB.js";
import {
  require_prop_types
} from "./chunk-UHG5BHY6.js";
import {
  require_react
} from "./chunk-VGQVIESM.js";
import {
  __toESM
} from "./chunk-TCQZMY3T.js";

// node_modules/react-timer-wrapper/es/index.js
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var TimerWrapper = function(_Component) {
  _inheritsLoose(TimerWrapper2, _Component);
  function TimerWrapper2(props) {
    var _this;
    _this = _Component.call(this, props) || this;
    _this.state = {
      duration: props.duration,
      startTime: props.active ? Date.now() - props.time : null,
      time: props.time
    };
    _this.tick = _this.tick.bind(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = TimerWrapper2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    var _this$state = this.state, duration = _this$state.duration, startTime = _this$state.startTime, time = _this$state.time;
    var _this$props = this.props, active = _this$props.active, onStart2 = _this$props.onStart;
    if (active) {
      onStart2({
        duration,
        progress: this.getProgress(time),
        time
      });
      this.animationFrame = requestAnimationFrame(this.tick);
    }
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this2 = this;
    var _this$props2 = this.props, active = _this$props2.active, duration = _this$props2.duration, time = _this$props2.time, onStart2 = _this$props2.onStart, onStop2 = _this$props2.onStop;
    if (prevProps.active === active && prevProps.time !== time && time !== this.state.time) {
      var timeDiff = this.state.time - time;
      this.setState({
        startTime: this.state.startTime + timeDiff,
        time: this.state.time + timeDiff
      });
      return;
    }
    if (prevProps.active !== active) {
      switch (active) {
        case true:
          var nextTime = duration !== null && this.state.time >= duration ? 0 : this.state.time;
          this.setState({
            startTime: Date.now() - nextTime,
            time: nextTime
          }, function() {
            onStart2({
              duration,
              progress: _this2.getProgress(nextTime),
              time: nextTime
            });
            _this2.animationFrame = requestAnimationFrame(_this2.tick);
          });
          break;
        case false:
          cancelAnimationFrame(this.animationFrame);
          onStop2({
            duration,
            progress: this.getProgress(this.state.time),
            time: this.state.time
          });
          break;
      }
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    cancelAnimationFrame(this.animationFrame);
  };
  _proto.getProgress = function getProgress(time) {
    var duration = this.state.duration;
    if (!duration) {
      return 0;
    }
    return Math.max(0, Math.min(1, time / duration));
  };
  _proto.tick = function tick() {
    var _this3 = this;
    var _this$props3 = this.props, duration = _this$props3.duration, loop = _this$props3.loop, time = _this$props3.time, onFinish2 = _this$props3.onFinish, onTimeUpdate2 = _this$props3.onTimeUpdate, onStart2 = _this$props3.onStart;
    var startTime = this.state.startTime;
    var nextTime = Date.now() - startTime;
    this.setState({
      time: nextTime
    }, function() {
      onTimeUpdate2({
        duration,
        progress: _this3.getProgress(nextTime),
        time: nextTime
      });
      if (duration !== null && nextTime >= duration) {
        onFinish2({
          duration,
          progress: _this3.getProgress(nextTime),
          time: nextTime
        });
        if (!loop) {
          cancelAnimationFrame(_this3.animationFrame);
          return;
        }
        nextTime = 0;
        onStart2({
          duration,
          progress: 0,
          time: nextTime
        });
        _this3.setState({
          startTime: Date.now()
        });
      }
      _this3.animationFrame = requestAnimationFrame(_this3.tick);
    });
  };
  _proto.render = function render() {
    var _this$props4 = this.props, children = _this$props4.children, component = _this$props4.component, duration = _this$props4.duration;
    var time = this.state.time;
    var progress = duration && time ? time / duration : 0;
    var clonedChildren = import_react.default.Children.toArray(children).map(function(child, childIndex) {
      return import_react.default.cloneElement(child, {
        duration,
        time,
        progress
      });
    });
    return import_react.default.createElement(component, _objectSpread({}, es_default(this.props)), clonedChildren);
  };
  return TimerWrapper2;
}(import_react.Component);
TimerWrapper.propTypes = {
  active: import_prop_types.default.bool,
  component: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.string]),
  duration: import_prop_types.default.number,
  loop: import_prop_types.default.bool,
  time: import_prop_types.default.number,
  onFinish: import_prop_types.default.func,
  onTimeUpdate: import_prop_types.default.func,
  onStart: import_prop_types.default.func
};
TimerWrapper.defaultProps = {
  active: false,
  component: "div",
  duration: 1e4,
  loop: false,
  time: 0,
  onFinish: function onFinish() {
  },
  onStart: function onStart() {
  },
  onStop: function onStop() {
  },
  onTimeUpdate: function onTimeUpdate() {
  }
};
var es_default2 = TimerWrapper;
export {
  es_default2 as default
};
//# sourceMappingURL=react-timer-wrapper.js.map
