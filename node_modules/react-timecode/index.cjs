/*! react-timecode !*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

var HTMLProps = ['accept', 'acceptCharset', 'accessKey', 'action', 'allowFullScreen', 'allowTransparency', // ?
'alt', 'async', 'autoComplete', 'autoFocus', 'autoPlay', 'capture', 'cellPadding', 'cellSpacing', 'challenge', 'charSet', 'checked', 'cite', 'classID', 'className', 'colSpan', 'cols', 'content', 'contentEditable', 'contextMenu', 'controls', 'controlsList', 'coords', 'crossOrigin', 'data', 'dateTime', 'default', 'defer', 'dir', 'disabled', 'download', 'draggable', 'encType', 'form', 'formAction', 'formEncType', 'formMethod', 'formNoValidate', 'formTarget', 'frameBorder', 'headers', 'height', 'hidden', 'high', 'href', 'hrefLang', 'htmlFor', 'httpEquiv', 'icon', 'id', 'inputMode', 'integrity', 'is', 'keyParams', 'keyType', 'kind', 'label', 'lang', 'list', 'loop', 'low', 'manifest', 'marginHeight', 'marginWidth', 'max', 'maxLength', 'media', 'mediaGroup', 'method', 'min', 'minLength', 'multiple', 'muted', 'name', 'noValidate', 'nonce', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'profile', 'radioGroup', 'readOnly', 'rel', 'required', 'reversed', 'role', 'rowSpan', 'rows', 'sandbox', 'scope', 'scoped', 'scrolling', 'seamless', 'selected', 'shape', 'size', 'sizes', 'span', 'spellCheck', 'src', 'srcDoc', 'srcLang', 'srcSet', 'start', 'step', 'style', 'summary', 'tabIndex', 'target', 'title', 'type', 'useMap', 'value', 'width', 'wmode', 'wrap'];
var RDFProps = ['about', 'datatype', 'inlist', 'prefix', 'property', 'resource', 'typeof', 'vocab'];
var ValidEvents = [// Clipboard Events
'onCopy', 'onCut', 'onPaste', // Composition Events
'onCompositionEnd', 'onCompositionStart', 'onCompositionUpdate', // Keyboard Events
'onKeyDown', 'onKeyPress', 'onKeyUp', // Focus Events
'onFocus', 'onBlur', // Form Events
'onChange', 'onInput', 'onInvalid', 'onReset', 'onSubmit', // Mouse Events
'onClick', 'onContextMenu', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', // Pointer Events
'onPointerDown', 'onPointerMove', 'onPointerUp', 'onPointerCancel', 'onGotPointerCapture', 'onLostPointerCapture', 'onPointerEnter', 'onPointerLeave', 'onPointerOver', 'onPointerOut', // Selection Events
'onSelect', // Touch Events
'onTouchCancel', 'onTouchEnd', 'onTouchMove', 'onTouchStart', // UI Events
'onScroll', // Wheel Events
'onWheel', // Media Events
'onAbort', 'onCanPlay', 'onCanPlayThrough', 'onDurationChange', 'onEmptied', 'onEncrypted', 'onEnded', 'onError', 'onLoadedData', 'onLoadedMetadata', 'onLoadStart', 'onPause', 'onPlay', 'onPlaying', 'onProgress', 'onRateChange', 'onSeeked', 'onSeeking', 'onStalled', 'onSuspend', 'onTimeUpdate', 'onVolumeChange', 'onWaiting', // Image Events
'onLoad', 'onError', // Animation Events
'onAnimationStart', 'onAnimationEnd', 'onAnimationIteration', // Transition Events
'onTransitionEnd', // Other Events
'onToggle'];

var DataRegex = /data-([a-zA-Z0-9\-]*)/;
var AriaRegex = /aria-([a-zA-Z0-9\-]*)/;
/**
 * Return an object containing the valid props to apply to an HTMLElement.
 *
 * @param {Object} props - Props to be filtered and applied to DOM element.
 * @param {Array} excludes - Array of props to exlude
 * @param {Array} customAttributes - Array of custom attributes to include
 * @return {Object}
 */

var cleanProps = function cleanProps(props, excludes, customAttributes) {
  if (props === void 0) {
    props = {};
  }

  if (excludes === void 0) {
    excludes = [];
  }

  if (customAttributes === void 0) {
    customAttributes = [];
  }

  var returnProps = Object.assign({}, props);
  var validProps = Object.keys(returnProps).filter(function (key) {
    if (excludes.indexOf(key) !== -1) {
      return false;
    }

    if (customAttributes.indexOf(key) > -1) {
      return true;
    }

    if (HTMLProps.indexOf(key) !== -1) {
      return true;
    }

    if (RDFProps.indexOf(key) !== -1) {
      return true;
    }

    if (DataRegex.test(key)) {
      return true;
    }

    if (AriaRegex.test(key)) {
      return true;
    }

    if (ValidEvents.indexOf(key) !== -1) {
      return true;
    }

    return false;
  });
  Object.keys(returnProps).forEach(function (key) {
    if (validProps.indexOf(key) === -1) {
      delete returnProps[key];
    }
  });
  return returnProps;
};

var SECOND = 1000;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;

/**
 * parseTime
 *
 * @param {Number} time
 * @returns {{ hours: Number, minutes: Number, seconds: Number, milliseconds: Number }}}
 */
var parseTime = function parseTime(time) {
  var milliseconds = time;
  var hours = milliseconds >= HOUR ? Math.floor(milliseconds / HOUR) : 0;
  if (hours) {
    milliseconds -= hours * HOUR;
  }
  var minutes = milliseconds >= MINUTE ? Math.floor(milliseconds / MINUTE) : 0;
  if (minutes) {
    milliseconds -= minutes * MINUTE;
  }
  var seconds = milliseconds >= SECOND ? Math.floor(milliseconds / SECOND) : 0;
  if (seconds) {
    milliseconds -= seconds * SECOND;
  }
  return {
    hours: hours,
    minutes: minutes,
    seconds: seconds,
    milliseconds: milliseconds
  };
};

/**
 * pad
 *
 * @param {Number} number
 * @param {Number} length
 * @returns {String}
 */
var pad = function pad(number) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var numberLength = number.toString().length;
  if (numberLength < length) {
    var diff = length - numberLength;
    var padding = '';
    while (padding.length < diff) {
      padding += '0';
    }
    return "".concat(padding).concat(number);
  }
  return "".concat(number);
};

/**
 * formatMilliseconds
 *
 * @param {Number} milliseconds
 * @param {Number} length
 * @returns {String}
 */
var formatMilliseconds = function formatMilliseconds(milliseconds) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  return pad((milliseconds / 1000).toFixed(length) * 1000, length);
};

/**
 * formatTimecode
 *
 * @param {Object} options
 * @param {String} options.format
 * @param {Number} options.time
 * @returns {String}
 */
var formatTimecode = function formatTimecode(_ref) {
  var format = _ref.format,
    time = _ref.time;
  var _parseTime = parseTime(time),
    hours = _parseTime.hours,
    minutes = _parseTime.minutes,
    seconds = _parseTime.seconds,
    milliseconds = _parseTime.milliseconds;
  switch (format) {
    case 'HH:mm:ss.SSS':
      return "".concat(pad(hours), ":").concat(pad(minutes), ":").concat(pad(seconds), ".").concat(formatMilliseconds(milliseconds));
    case 'H:mm:ss.SSS':
      return "".concat(hours, ":").concat(pad(minutes), ":").concat(pad(seconds), ".").concat(formatMilliseconds(milliseconds));
    case 'H:?mm:ss.SSS':
      if (hours) {
        return "".concat(hours, ":").concat(pad(minutes), ":").concat(pad(seconds), ".").concat(formatMilliseconds(milliseconds));
      }
      return "".concat(pad(minutes), ":").concat(pad(seconds), ".").concat(formatMilliseconds(milliseconds));
    case 'H:?m:ss.SSS':
      if (hours) {
        return "".concat(hours, ":").concat(pad(minutes), ":").concat(pad(seconds), ".").concat(formatMilliseconds(milliseconds));
      }
      return "".concat(minutes, ":").concat(pad(seconds), ".").concat(formatMilliseconds(milliseconds));
    case 'HH:mm:ss':
      return "".concat(pad(hours), ":").concat(pad(minutes), ":").concat(pad(seconds));
    case 'H:mm:ss':
      return "".concat(hours, ":").concat(pad(minutes), ":").concat(pad(seconds));
    case 'H:?mm:ss':
      if (hours) {
        return "".concat(hours, ":").concat(pad(minutes), ":").concat(pad(seconds));
      }
      return "".concat(pad(minutes), ":").concat(pad(seconds));
    case 'H:mm':
      return "".concat(hours, ":").concat(pad(minutes));
    case 's.SSS':
      return "".concat(seconds, ".").concat(formatMilliseconds(milliseconds));
    case 's.SS':
      return "".concat(seconds, ".").concat(formatMilliseconds(milliseconds, 2));
    case 'mm:ss':
      return "".concat(pad(minutes + hours * 60), ":").concat(pad(seconds));
    case 'H:?m:ss':
    default:
      if (hours) {
        return "".concat(hours, ":").concat(pad(minutes), ":").concat(pad(seconds));
      }
      return "".concat(minutes, ":").concat(pad(seconds));
  }
};

var _excluded = ["as", "component", "format", "postfix", "prefix", "time"];

/**
 * Timecode - React Component
 *
 * @param {Object} props
 * @param {String} [props.as='span'] - HTML element to render
 * @param {String} [props.component] - HTML element to render [DEPRECATED
 * @param {String} [props.format='H:?m:ss'] - Timecode format
 * @param {String} [props.postfix=''] - Postfix to append to timecode
 * @param {String} [props.prefix=''] - Prefix to prepend to timecode
 * @param {Number} [props.time=0] - Time in milliseconds
 * @param {Object} [rest] - Additional props to pass to HTML element
 * @param {React.Ref} [ref] - React ref
 * @returns {React.ReactElement}
 */
var Timecode = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$as = _ref.as,
    asProp = _ref$as === void 0 ? 'span' : _ref$as,
    component = _ref.component,
    _ref$format = _ref.format,
    format = _ref$format === void 0 ? 'H:?m:ss' : _ref$format,
    _ref$postfix = _ref.postfix,
    postfix = _ref$postfix === void 0 ? '' : _ref$postfix,
    _ref$prefix = _ref.prefix,
    prefix = _ref$prefix === void 0 ? '' : _ref$prefix,
    _ref$time = _ref.time,
    time = _ref$time === void 0 ? 0 : _ref$time,
    rest = _objectWithoutProperties(_ref, _excluded);
  var timecode = React.useMemo(function () {
    return formatTimecode({
      format: format,
      time: time
    });
  }, [format, time]);
  var Component = component || asProp;
  return /*#__PURE__*/React.createElement(Component, _extends({}, cleanProps(rest), {
    ref: ref
  }), "".concat(prefix).concat(timecode).concat(postfix));
});

exports.Timecode = Timecode;
exports.default = Timecode;
exports.formatMilliseconds = formatMilliseconds;
exports.formatTimecode = formatTimecode;
exports.pad = pad;
exports.parseTime = parseTime;
/* Copyright 2018 - 2023 - Ryan Hefner <hi@ryanhefner.com> (https://www.ryanhefner.com) */
